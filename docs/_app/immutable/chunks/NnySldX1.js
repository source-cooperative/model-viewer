import{h as m,l as p,T as h,a9 as y,u as b,r as w}from"./Mxg7T9gF.js";import{A as c,G as g}from"./3UQ8_E_Z.js";class A{constructor(n,e,t){this.frame=n,this.action=e,this.onlyOnce=t,this.isDone=!1}_clone(){return new A(this.frame,this.action,this.onlyOnce)}}class E{constructor(n,e,t){if(this.loop=!1,this._coneInnerAngle=360,this._coneOuterAngle=360,this._volume=1,this.isPlaying=!1,this.isPaused=!1,this._sounds=[],this._weights=[],e.length!==t.length)throw new Error("Sounds length does not equal weights length");this.loop=n,this._weights=t;let s=0;for(const r of t)s+=r;const i=s>0?1/s:0;for(let r=0;r<this._weights.length;r++)this._weights[r]*=i;this._sounds=e;for(const r of this._sounds)r.onEndedObservable.add(()=>{this._onended()})}get directionalConeInnerAngle(){return this._coneInnerAngle}set directionalConeInnerAngle(n){if(n!==this._coneInnerAngle){if(this._coneOuterAngle<n){m.Error("directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.");return}this._coneInnerAngle=n;for(const e of this._sounds)e.directionalConeInnerAngle=n}}get directionalConeOuterAngle(){return this._coneOuterAngle}set directionalConeOuterAngle(n){if(n!==this._coneOuterAngle){if(n<this._coneInnerAngle){m.Error("directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.");return}this._coneOuterAngle=n;for(const e of this._sounds)e.directionalConeOuterAngle=n}}get volume(){return this._volume}set volume(n){if(n!==this._volume)for(const e of this._sounds)e.setVolume(n)}_onended(){this._currentIndex!==void 0&&(this._sounds[this._currentIndex].autoplay=!1),this.loop&&this.isPlaying?this.play():this.isPlaying=!1}pause(){this.isPlaying&&(this.isPaused=!0,this._currentIndex!==void 0&&this._sounds[this._currentIndex].pause())}stop(){this.isPlaying=!1,this._currentIndex!==void 0&&this._sounds[this._currentIndex].stop()}play(n){if(!this.isPaused){this.stop();const t=Math.random();let s=0;for(let i=0;i<this._weights.length;i++)if(s+=this._weights[i],t<=s){this._currentIndex=i;break}}const e=this._sounds[this._currentIndex??0];e.isReady()?e.play(0,this.isPaused?void 0:n):e.autoplay=!0,this.isPlaying=!0,this.isPaused=!1}}const f="MSFT_audio_emitter";class I{constructor(n){this.name=f,this._loader=n,this.enabled=this._loader.isExtensionUsed(f)}dispose(){this._loader=null,this._clips=null,this._emitters=null}onLoading(){const n=this._loader.gltf.extensions;if(n&&n[this.name]){const e=n[this.name];this._clips=e.clips,this._emitters=e.emitters,c.Assign(this._clips),c.Assign(this._emitters)}}loadSceneAsync(n,e){return g.LoadExtensionAsync(n,e,this.name,async(t,s)=>{const i=new Array;i.push(this._loader.loadSceneAsync(n,e));for(const r of s.emitters){const o=c.Get(`${t}/emitters`,this._emitters,r);if(o.refDistance!=null||o.maxDistance!=null||o.rolloffFactor!=null||o.distanceModel!=null||o.innerAngle!=null||o.outerAngle!=null)throw new Error(`${t}: Direction or Distance properties are not allowed on emitters attached to a scene`);i.push(this._loadEmitterAsync(`${t}/emitters/${o.index}`,o))}await Promise.all(i)})}loadNodeAsync(n,e,t){return g.LoadExtensionAsync(n,e,this.name,async(s,i)=>{const r=new Array,o=await this._loader.loadNodeAsync(s,e,a=>{for(const d of i.emitters){const l=c.Get(`${s}/emitters`,this._emitters,d);r.push(this._loadEmitterAsync(`${s}/emitters/${l.index}`,l).then(()=>{for(const u of l._babylonSounds)u.attachToMesh(a),(l.innerAngle!=null||l.outerAngle!=null)&&(u.setLocalDirectionToMesh(p.Forward()),u.setDirectionalCone(2*h.ToDegrees(l.innerAngle==null?Math.PI:l.innerAngle),2*h.ToDegrees(l.outerAngle==null?Math.PI:l.outerAngle),0))}))}t(a)});return await Promise.all(r),o})}loadAnimationAsync(n,e){return g.LoadExtensionAsync(n,e,this.name,async(t,s)=>{const i=await this._loader.loadAnimationAsync(n,e),r=new Array;c.Assign(s.events);for(const o of s.events)r.push(this._loadAnimationEventAsync(`${t}/events/${o.index}`,n,e,o,i));return await Promise.all(r),i})}_loadClipAsync(n,e){if(e._objectURL)return e._objectURL;let t;if(e.uri)t=this._loader.loadUriAsync(n,e,e.uri);else{const s=c.Get(`${n}/bufferView`,this._loader.gltf.bufferViews,e.bufferView);t=this._loader.loadBufferViewAsync(`/bufferViews/${s.index}`,s)}return e._objectURL=t.then(s=>URL.createObjectURL(new Blob([s],{type:e.mimeType}))),e._objectURL}_loadEmitterAsync(n,e){if(e._babylonSounds=e._babylonSounds||[],!e._babylonData){const t=new Array,s=e.name||`emitter${e.index}`,i={loop:!1,autoplay:!1,volume:e.volume==null?1:e.volume};for(let o=0;o<e.clips.length;o++){const a=`/extensions/${this.name}/clips`,d=c.Get(a,this._clips,e.clips[o].clip);t.push(this._loadClipAsync(`${a}/${e.clips[o].clip}`,d).then(l=>{const u=e._babylonSounds[o]=new y(s,l,this._loader.babylonScene,null,i);u.refDistance=e.refDistance||1,u.maxDistance=e.maxDistance||256,u.rolloffFactor=e.rolloffFactor||1,u.distanceModel=e.distanceModel||"exponential"}))}const r=Promise.all(t).then(()=>{const o=e.clips.map(d=>d.weight||1),a=new E(e.loop||!1,e._babylonSounds,o);e.innerAngle&&(a.directionalConeInnerAngle=2*h.ToDegrees(e.innerAngle)),e.outerAngle&&(a.directionalConeOuterAngle=2*h.ToDegrees(e.outerAngle)),e.volume&&(a.volume=e.volume),e._babylonData.sound=a});e._babylonData={loaded:r}}return e._babylonData.loaded}_getEventAction(n,e,t,s,i){switch(t){case"play":return r=>{const o=(i||0)+(r-s);e.play(o)};case"stop":return()=>{e.stop()};case"pause":return()=>{e.pause()};default:throw new Error(`${n}: Unsupported action ${t}`)}}_loadAnimationEventAsync(n,e,t,s,i){if(i.targetedAnimations.length==0)return Promise.resolve();const r=i.targetedAnimations[0],o=s.emitter,a=c.Get(`/extensions/${this.name}/emitters`,this._emitters,o);return this._loadEmitterAsync(n,a).then(()=>{const d=a._babylonData.sound;if(d){const l=new A(s.time,this._getEventAction(n,d,s.action,s.time,s.startOffset));r.animation.addEvent(l),i.onAnimationGroupEndObservable.add(()=>{d.stop()}),i.onAnimationGroupPauseObservable.add(()=>{d.pause()})}})}}b(f);w(f,!0,_=>new I(_));export{I as MSFT_audio_emitter};
