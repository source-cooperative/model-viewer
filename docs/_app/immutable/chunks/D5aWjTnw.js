import{a5 as W,a6 as N,M as Q,a3 as Y,T as K,a7 as T,a8 as Z,l as z,A as tt,h as et,X as nt,R as st}from"./Mxg7T9gF.js";function ot(l,r,o){const t=new Uint8Array(l),p=new Uint32Array(l.slice(0,12)),s=p[2],m=t[12],g=t[13],x=t[14],b=t[15],M=p[1];if(b||p[0]!=1347635022||M!=2&&M!=3)return new Promise(n=>{n({mode:3,data:i,hasVertexColors:!1})});const h=32,i=new ArrayBuffer(h*s),f=1/(1<<g),w=new Int32Array(1),_=new Uint8Array(w.buffer),R=function(n,a){return _[0]=n[a+0],_[1]=n[a+1],_[2]=n[a+2],_[3]=n[a+2]&128?255:0,w[0]*f};let e=16;const C=new Float32Array(i),c=new Float32Array(i),k=new Uint8ClampedArray(i),y=new Uint8ClampedArray(i);for(let n=0;n<s;n++)C[n*8+0]=R(t,e+0),C[n*8+1]=R(t,e+3),C[n*8+2]=R(t,e+6),e+=9;const d=.282;for(let n=0;n<s;n++){for(let a=0;a<3;a++){const I=(t[e+s+n*3+a]-127.5)/(.15*255);k[n*32+24+a]=W.Clamp((.5+d*I)*255,0,255)}k[n*32+24+3]=t[e+n]}e+=s*4;for(let n=0;n<s;n++)c[n*8+3+0]=Math.exp(t[e+0]/16-10),c[n*8+3+1]=Math.exp(t[e+1]/16-10),c[n*8+3+2]=Math.exp(t[e+2]/16-10),e+=3;if(M>=3){const n=Math.SQRT1_2;for(let a=0;a<s;a++){const E=[t[e+0],t[e+1],t[e+2],t[e+3]],I=E[0]+(E[1]<<8)+(E[2]<<16)+(E[3]<<24),v=511,u=[],V=I>>>30;let U=I,A=0;for(let S=3;S>=0;--S)if(S!==V){const F=U&v,L=U>>>9&1;U=U>>>10,u[S]=n*(F/v),L===1&&(u[S]=-u[S]),A+=u[S]*u[S]}const O=1-A;u[V]=Math.sqrt(Math.max(O,0));const P=[3,0,1,2];for(let S=0;S<4;S++)y[a*32+28+S]=Math.round(127.5+u[P[S]]*127.5);e+=4}}else for(let n=0;n<s;n++){const a=t[e+0],E=t[e+1],I=t[e+2],v=a/127.5-1,u=E/127.5-1,V=I/127.5-1;y[n*32+28+1]=a,y[n*32+28+2]=E,y[n*32+28+3]=I;const U=1-(v*v+u*u+V*V);y[n*32+28+0]=127.5+Math.sqrt(U<0?0:U)*127.5,e+=3}if(m){const a=((m+1)*(m+1)-1)*3,E=Math.ceil(a/16);let I=e;const v=[],V=r.getEngine().getCaps().maxTextureSize,U=Math.ceil(s/V);for(let A=0;A<E;A++){const O=new Uint8Array(U*V*4*4);v.push(O)}for(let A=0;A<s;A++)for(let O=0;O<a;O++){const P=t[I++],S=Math.floor(O/16),F=v[S],L=O%16,B=A*16;F[L+B]=P}return new Promise(A=>{A({mode:0,data:i,hasVertexColors:!1,sh:v,trainedWithAntialiasing:!!x})})}return new Promise(n=>{n({mode:0,data:i,hasVertexColors:!1,trainedWithAntialiasing:!!x})})}const D=.28209479177387814;async function H(l,r,o){return await new Promise((p,s)=>{const m=o.createCanvasImage();if(!m)throw new Error("Failed to create ImageBitmap");m.onload=()=>{try{const x=o.createCanvas(m.width,m.height);if(!x)throw new Error("Failed to create canvas");const b=x.getContext("2d");if(!b)throw new Error("Failed to get 2D context");b.drawImage(m,0,0);const M=b.getImageData(0,0,x.width,x.height);p({bits:new Uint8Array(M.data.buffer),width:M.width})}catch(x){s(`Error loading image ${m.src} with exception: ${x}`)}},m.onerror=x=>{s(`Error loading image ${m.src} with exception: ${x}`)},m.crossOrigin="anonymous";let g;if(typeof l=="string"){if(!r)throw new Error("filename is required when using a URL");m.src=l+r}else{const x=new Blob([l],{type:"image/webp"});g=URL.createObjectURL(x),m.src=g}})}async function at(l,r,o){const t=l.count?l.count:l.means.shape[0],p=32,s=new ArrayBuffer(p*t),m=new Float32Array(s),g=new Float32Array(s),x=new Uint8ClampedArray(s),b=new Uint8ClampedArray(s),M=e=>Math.sign(e)*(Math.exp(Math.abs(e))-1),h=r[0].bits,i=r[1].bits;if(!Array.isArray(l.means.mins)||!Array.isArray(l.means.maxs))throw new Error("Missing arrays in SOG data.");for(let e=0;e<t;e++){const C=e*4;for(let c=0;c<3;c++){const k=l.means.mins[c],y=l.means.maxs[c],d=i[C+c],n=h[C+c],a=d<<8|n,E=W.Lerp(k,y,a/65535);m[e*8+c]=M(E)}}const f=r[2].bits;if(l.version===2){if(!l.scales.codebook)throw new Error("Missing codebook in SOG version 2 scales data.");for(let e=0;e<t;e++){const C=e*4;for(let c=0;c<3;c++){const k=l.scales.codebook[f[C+c]],y=Math.exp(k);g[e*8+3+c]=y}}}else{if(!Array.isArray(l.scales.mins)||!Array.isArray(l.scales.maxs))throw new Error("Missing arrays in SOG scales data.");for(let e=0;e<t;e++){const C=e*4;for(let c=0;c<3;c++){const k=f[C+c],y=W.Lerp(l.scales.mins[c],l.scales.maxs[c],k/255),d=Math.exp(y);g[e*8+3+c]=d}}}const w=r[4].bits;if(l.version===2){if(!l.sh0.codebook)throw new Error("Missing codebook in SOG version 2 sh0 data.");for(let e=0;e<t;e++){const C=e*4;for(let c=0;c<3;c++){const k=.5+l.sh0.codebook[w[C+c]]*D;x[e*32+24+c]=Math.max(0,Math.min(255,Math.round(255*k)))}x[e*32+24+3]=w[C+3]}}else{if(!Array.isArray(l.sh0.mins)||!Array.isArray(l.sh0.maxs))throw new Error("Missing arrays in SOG sh0 data.");for(let e=0;e<t;e++){const C=e*4;for(let c=0;c<4;c++){const k=l.sh0.mins[c],y=l.sh0.maxs[c],d=w[C+c],n=W.Lerp(k,y,d/255);let a;c<3?a=.5+n*D:a=1/(1+Math.exp(-n)),x[e*32+24+c]=Math.max(0,Math.min(255,Math.round(255*a)))}}}const _=e=>(e/255-.5)*2/Math.SQRT2,R=r[3].bits;for(let e=0;e<t;e++){const C=R[e*4+0],c=R[e*4+1],k=R[e*4+2],y=R[e*4+3],d=_(C),n=_(c),a=_(k),E=y-252,I=d*d+n*n+a*a,v=Math.sqrt(Math.max(0,1-I));let u;switch(E){case 0:u=[v,d,n,a];break;case 1:u=[d,v,n,a];break;case 2:u=[d,n,v,a];break;case 3:u=[d,n,a,v];break;default:throw new Error("Invalid quaternion mode")}b[e*32+28+0]=u[0]*127.5+127.5,b[e*32+28+1]=u[1]*127.5+127.5,b[e*32+28+2]=u[2]*127.5+127.5,b[e*32+28+3]=u[3]*127.5+127.5}if(l.shN){const e=[0,3,8,15],C=l.shN.bands?e[l.shN.bands]:l.shN.shape[1]/3,c=r[5].bits,k=r[6].bits,y=r[5].width,d=C*3,n=Math.ceil(d/16),a=[],I=o.getEngine().getCaps().maxTextureSize,v=Math.ceil(t/I);for(let u=0;u<n;u++){const V=new Uint8Array(v*I*4*4);a.push(V)}if(l.version===2){if(!l.shN.codebook)throw new Error("Missing codebook in SOG version 2 shN data.");for(let u=0;u<t;u++){const V=k[u*4+0]+(k[u*4+1]<<8),U=V%64*C,A=Math.floor(V/64);for(let O=0;O<C;O++)for(let P=0;P<3;P++){const S=O*3+P,F=Math.floor(S/16),L=a[F],B=S%16,G=u*16,j=l.shN.codebook[c[(U+O)*4+P+A*y*4]]*127.5+127.5;L[B+G]=Math.max(0,Math.min(255,j))}}}else for(let u=0;u<t;u++){const V=k[u*4+0]+(k[u*4+1]<<8),U=V%64*C,A=Math.floor(V/64),O=l.shN.mins,P=l.shN.maxs;for(let S=0;S<3;S++)for(let F=0;F<C/3;F++){const L=F*3+S,B=Math.floor(L/16),G=a[B],j=L%16,X=u*16,J=W.Lerp(O,P,c[(U+F)*4+S+A*y*4]/255)*127.5+127.5;G[j+X]=Math.max(0,Math.min(255,J))}}return await new Promise(u=>{u({mode:0,data:s,hasVertexColors:!1,sh:a})})}return await new Promise(e=>{e({mode:0,data:s,hasVertexColors:!1})})}async function $(l,r,o){let t,p;if(l instanceof Map){p=l;const g=p.get("meta.json");if(!g)throw new Error("meta.json not found in files Map");t=JSON.parse(new TextDecoder().decode(g))}else t=l;const s=[...t.means.files,...t.scales.files,...t.quats.files,...t.sh0.files];t.shN&&s.push(...t.shN.files);const m=await Promise.all(s.map(async g=>{if(p&&p.has(g)){const x=p.get(g);return await H(x,g,o.getEngine())}else return await H(r,g,o.getEngine())}));return await at(t,m,o)}class q{constructor(r=q._DefaultLoadingOptions){this.name=N.name,this._assetContainer=null,this.extensions=N.extensions,this._loadingOptions=r}createPlugin(r){return new q(r[N.name])}async importMeshAsync(r,o,t,p,s,m){return await this._parseAsync(r,o,t,p).then(g=>({meshes:g,particleSystems:[],skeletons:[],animationGroups:[],transformNodes:[],geometries:[],lights:[],spriteManagers:[]}))}static _BuildPointCloud(r,o){if(!o.byteLength)return!1;const t=new Uint8Array(o),p=new Float32Array(o),s=32,m=t.length/s,g=function(x,b){const M=p[8*b+0],h=p[8*b+1],i=p[8*b+2];x.position=new z(M,h,i);const f=t[s*b+24+0]/255,w=t[s*b+24+1]/255,_=t[s*b+24+2]/255;x.color=new nt(f,w,_,1)};return r.addPoints(m,g),!0}static _BuildMesh(r,o){const t=new Q("PLYMesh",r),p=new Uint8Array(o.data),s=new Float32Array(o.data),m=32,g=p.length/m,x=[],b=new Y;for(let M=0;M<g;M++){const h=s[8*M+0],i=s[8*M+1],f=s[8*M+2];x.push(h,i,f)}if(o.hasVertexColors){const M=new Float32Array(g*4);for(let h=0;h<g;h++){const i=p[m*h+24+0]/255,f=p[m*h+24+1]/255,w=p[m*h+24+2]/255;M[h*4+0]=i,M[h*4+1]=f,M[h*4+2]=w,M[h*4+3]=1}b.colors=M}return b.positions=x,b.indices=o.faces,b.applyToMesh(t),t}async _unzipWithFFlateAsync(r){let o=this._loadingOptions.fflate;o||(typeof window.fflate>"u"&&await K.LoadScriptAsync(this._loadingOptions.deflateURL??"https://unpkg.com/fflate/umd/index.js"),o=window.fflate);const{unzipSync:t}=o,p=t(r),s=new Map;for(const[m,g]of Object.entries(p))s.set(m,g);return s}_parseAsync(r,o,t,p){const s=[],m=h=>{o._blockEntityCollection=!!this._assetContainer;const i=this._loadingOptions.gaussianSplattingMesh??new T("GaussianSplatting",null,o,this._loadingOptions.keepInRam);i._parentContainer=this._assetContainer,s.push(i),i.updateData(h.data,h.sh,{flipY:!1}),i.scaling.y*=-1,i.computeWorldMatrix(!0),o._blockEntityCollection=!1};if(typeof t=="string"){const h=JSON.parse(t);if(h&&h.means&&h.scales&&h.quats&&h.sh0)return new Promise(i=>{$(h,p,o).then(f=>{m(f),i(s)}).catch(()=>{throw new Error("Failed to parse SOG data.")})})}const g=t instanceof ArrayBuffer?new Uint8Array(t):t;if(g[0]===80&&g[1]===75)return new Promise(h=>{this._unzipWithFFlateAsync(g).then(i=>{$(i,p,o).then(f=>{m(f),h(s)}).catch(()=>{throw new Error("Failed to parse SOG zip data.")})})});const x=new ReadableStream({start(h){h.enqueue(new Uint8Array(t)),h.close()}}),b=new DecompressionStream("gzip"),M=x.pipeThrough(b);return new Promise(h=>{new Response(M).arrayBuffer().then(i=>{ot(i,o,this._loadingOptions).then(f=>{o._blockEntityCollection=!!this._assetContainer;const w=this._loadingOptions.gaussianSplattingMesh??new T("GaussianSplatting",null,o,this._loadingOptions.keepInRam);if(f.trainedWithAntialiasing){const _=w.material;_.kernelSize=.1,_.compensation=!0}w._parentContainer=this._assetContainer,s.push(w),w.updateData(f.data,f.sh,{flipY:!1}),this._loadingOptions.flipY||(w.scaling.y*=-1,w.computeWorldMatrix(!0)),o._blockEntityCollection=!1,this.applyAutoCameraLimits(f,o),h(s)})}).catch(()=>{q._ConvertPLYToSplat(t).then(async i=>{switch(o._blockEntityCollection=!!this._assetContainer,i.mode){case 0:{const f=this._loadingOptions.gaussianSplattingMesh??new T("GaussianSplatting",null,o,this._loadingOptions.keepInRam);switch(f._parentContainer=this._assetContainer,s.push(f),f.updateData(i.data,i.sh,{flipY:!1}),f.scaling.y*=-1,i.chirality==="RightHanded"&&(f.scaling.y*=-1),i.upAxis){case"X":f.rotation=new z(0,0,Math.PI/2);break;case"Y":f.rotation=new z(0,0,Math.PI);break;case"Z":f.rotation=new z(-Math.PI/2,Math.PI,0);break}f.computeWorldMatrix(!0)}break;case 1:{const f=new Z("PointCloud",1,o);q._BuildPointCloud(f,i.data)?await f.buildMeshAsync().then(w=>{s.push(w)}):f.dispose()}break;case 2:if(i.faces)s.push(q._BuildMesh(o,i));else throw new Error("PLY mesh doesn't contain face informations.");break;default:throw new Error("Unsupported Splat mode")}o._blockEntityCollection=!1,this.applyAutoCameraLimits(i,o),h(s)})})})}applyAutoCameraLimits(r,o){if(!this._loadingOptions.disableAutoCameraLimits&&(r.safeOrbitCameraRadiusMin!==void 0||r.safeOrbitCameraElevationMinMax!==void 0)&&o.activeCamera?.getClassName()==="ArcRotateCamera"){const t=o.activeCamera;r.safeOrbitCameraElevationMinMax&&(t.lowerBetaLimit=Math.PI*.5-r.safeOrbitCameraElevationMinMax[1],t.upperBetaLimit=Math.PI*.5-r.safeOrbitCameraElevationMinMax[0]),r.safeOrbitCameraRadiusMin&&(t.lowerRadiusLimit=r.safeOrbitCameraRadiusMin)}}loadAssetContainerAsync(r,o,t){const p=new tt(r);return this._assetContainer=p,this.importMeshAsync(null,r,o,t).then(s=>{for(const m of s.meshes)p.meshes.push(m);return this._assetContainer=null,p}).catch(s=>{throw this._assetContainer=null,s})}loadAsync(r,o,t){return this.importMeshAsync(null,r,o,t).then(()=>{})}static _ConvertPLYToSplat(r){const o=new Uint8Array(r),t=new TextDecoder().decode(o.slice(0,1024*10)),p=`end_header
`,s=t.indexOf(p);if(s<0||!t)return new Promise(y=>{y({mode:0,data:r,rawSplat:!0})});const m=parseInt(/element vertex (\d+)\n/.exec(t)[1]),g=/element face (\d+)\n/.exec(t);let x=0;g&&(x=parseInt(g[1]));const b=/element chunk (\d+)\n/.exec(t);let M=0;b&&(M=parseInt(b[1]));let h=0,i=0;const f={double:8,int:4,uint:4,float:4,short:2,ushort:2,uchar:1,list:0},w={Vertex:0,Chunk:1,SH:2,Float_Tuple:3,Float:4,Uchar:5};let _=w.Chunk;const R=[],e=t.slice(0,s).split(`
`),C={};for(const y of e)if(y.startsWith("property ")){const[,d,n]=y.split(" ");if(_==w.Chunk)i+=f[d];else if(_==w.Vertex)R.push({name:n,type:d,offset:h}),h+=f[d];else if(_==w.SH)R.push({name:n,type:d,offset:h});else if(_==w.Float_Tuple){const a=new DataView(r,i,f.float*2);C.safeOrbitCameraElevationMinMax=[a.getFloat32(0,!0),a.getFloat32(4,!0)]}else if(_==w.Float){const a=new DataView(r,i,f.float);C.safeOrbitCameraRadiusMin=a.getFloat32(0,!0)}else if(_==w.Uchar){const a=new DataView(r,i,f.uchar);n=="up_axis"?C.upAxis=a.getUint8(0)==0?"X":a.getUint8(0)==1?"Y":"Z":n=="chirality"&&(C.chirality=a.getUint8(0)==0?"LeftHanded":"RightHanded")}f[d]||et.Warn(`Unsupported property type: ${d}.`)}else if(y.startsWith("element ")){const[,d]=y.split(" ");d=="chunk"?_=w.Chunk:d=="vertex"?_=w.Vertex:d=="sh"?_=w.SH:d=="safe_orbit_camera_elevation_min_max_radians"?_=w.Float_Tuple:d=="safe_orbit_camera_radius_min"?_=w.Float:(d=="up_axis"||d=="chirality")&&(_=w.Uchar)}const c=h,k=i;return T.ConvertPLYWithSHToSplatAsync(r).then(async y=>{const d=new DataView(r,s+p.length);let n=k*M+c*m;const a=[];if(x)for(let A=0;A<x;A++){const O=d.getUint8(n);if(O==3){n+=1;for(let P=0;P<O;P++){const S=d.getUint32(n+(2-P)*4,!0);a.push(S)}n+=12}}if(M)return await new Promise(A=>{A({mode:0,data:y.buffer,sh:y.sh,faces:a,hasVertexColors:!1,compressed:!0,rawSplat:!1})});let E=0,I=0;const v=["x","y","z","scale_0","scale_1","scale_2","opacity","rot_0","rot_1","rot_2","rot_3"],u=["red","green","blue","f_dc_0","f_dc_1","f_dc_2"];for(let A=0;A<R.length;A++){const O=R[A];v.includes(O.name)&&E++,u.includes(O.name)&&I++}const V=E==v.length&&I==3,U=x?2:V?0:1;return await new Promise(A=>{A({...C,mode:U,data:y.buffer,sh:y.sh,faces:a,hasVertexColors:!!I,compressed:!1,rawSplat:!1})})})}}q._DefaultLoadingOptions={keepInRam:!1,flipY:!1};st(new q);export{q as SPLATFileLoader};
