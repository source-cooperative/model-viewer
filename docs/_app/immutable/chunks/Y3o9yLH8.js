import{I as Y,o as h,l as E,m as p,T as U,Q as R,J as b,N as g,A as D,R as V}from"./Mxg7T9gF.js";const O="Xposition",F="Yposition",k="Zposition",x="Xrotation",v="Yrotation",M="Zrotation",j="HIERARCHY",K="MOTION";class X{constructor(t){this.loopMode=h.ANIMATIONLOOPMODE_CYCLE,this.list=[],this.root=_(),this.numFrames=0,this.frameRate=0,this.skeleton=t}}function _(){return{name:"",type:"",offset:new E,channels:[],children:[],frames:[],parent:null}}function Z(){return{frame:0,position:new E,rotation:new R}}function z(n){const t=n.offset.x,o=n.offset.y,i=n.offset.z;return p.Translation(t,o,i)}function Q(n,t){if(n.frames.length===0)return[];const o=[],i=n.channels.some(f=>f===O||f===F||f===k),e=n.channels.some(f=>f===x||f===v||f===M),r=new h(`${n.name}_pos`,"position",t.frameRate,h.ANIMATIONTYPE_VECTOR3,t.loopMode),a=new h(`${n.name}_rot`,"rotationQuaternion",t.frameRate,h.ANIMATIONTYPE_QUATERNION,t.loopMode),s=[],l=[];for(let f=0;f<n.frames.length;f++){const c=n.frames[f];i&&c.position&&s.push({frame:c.frame,value:c.position.clone()}),e&&l.push({frame:c.frame,value:c.rotation.clone()})}return s.length>0&&(r.setKeys(s),o.push(r)),l.length>0&&(a.setKeys(l),o.push(a)),o}function P(n,t,o){const i=z(n),e=new b(n.name,o.skeleton,t,i),r=Q(n,o);for(const a of r)a.getKeys()&&a.getKeys().length>0&&e.animations.push(a);for(const a of n.children)P(a,e,o)}function B(n,t,o,i){if(o.type==="ENDSITE")return;const e=Z();e.frame=t,e.position=new E,e.rotation=new R,o.frames.push(e);let r=p.Identity();for(let a=0;a<o.channels.length;++a){const s=o.channels[a],l=n[i.i++];if(!l)continue;const f=parseFloat(l.trim());if(s.endsWith("position"))switch(s){case O:e.position.x=f;break;case F:e.position.y=f;break;case k:e.position.z=f;break}else if(s.endsWith("rotation")){const c=U.ToRadians(f);let m;switch(s){case x:m=p.RotationX(c);break;case v:m=p.RotationY(c);break;case M:m=p.RotationZ(c);break}r=m.multiply(r)}}R.FromRotationMatrixToRef(r,e.rotation);for(const a of o.children)B(n,t,a,i)}function L(n,t,o,i){const e=_();e.parent=o,i.list.push(e);let r=t.trim().split(/\s+/);if(r[0].toUpperCase()==="END"&&r[1].toUpperCase()==="SITE"?(e.type="ENDSITE",e.name="ENDSITE"):(e.name=r[1],e.type=r[0].toUpperCase()),n.shift()?.trim()!="{")throw new Error("Expected opening { after type & name");const a=n.shift()?.trim().split(/\s+/);if(!a)throw new Error("Unexpected end of file: missing OFFSET");if(r=a,r[0].toUpperCase()!="OFFSET")throw new Error("Expected OFFSET, but got: "+r[0]);if(r.length!=4)throw new Error("OFFSET: Invalid number of values");const s=new E(parseFloat(r[1]),parseFloat(r[2]),parseFloat(r[3]));if(isNaN(s.x)||isNaN(s.y)||isNaN(s.z))throw new Error("OFFSET: Invalid values");if(e.offset=s,e.type!="ENDSITE"){if(r=n.shift()?.trim().split(/\s+/),!r)throw new Error("Unexpected end of file: missing CHANNELS");if(r[0].toUpperCase()!="CHANNELS")throw new Error("Expected CHANNELS definition");const l=parseInt(r[1]);e.channels=r.splice(2,l),e.children=[]}for(;n.length>0;){const l=n.shift()?.trim();if(l==="}")return e;l&&e.children.push(L(n,l,e,i))}throw new Error("Unexpected end of file: missing closing brace")}function A(n,t,o,i){const e=n.split(`
`),{loopMode:r}=i;t._blockEntityCollection=!!o;const a=new Y("","",t);a._parentContainer=o,t._blockEntityCollection=!1;const s=new X(a);s.loopMode=r;const l=e.shift();if(!l||l.trim().toUpperCase()!==j)throw new Error("HIERARCHY expected");const f=e.shift();if(!f)throw new Error("Unexpected end of file after HIERARCHY");const c=L(e,f.trim(),null,s),m=e.shift();if(!m||m.trim().toUpperCase()!==K)throw new Error("MOTION expected");const y=e.shift();if(!y)throw new Error("Unexpected end of file before frame count");const C=y.trim().split(/[\s]+/);if(C.length<2)throw new Error("Invalid frame count line");const w=parseInt(C[1]);if(isNaN(w))throw new Error("Failed to read number of frames.");s.numFrames=w;const H=e.shift();if(!H)throw new Error("Unexpected end of file before frame time");const I=H.trim().split(/[\s]+/);if(I.length<3)throw new Error("Invalid frame time line");const u=parseFloat(I[2]);if(isNaN(u))throw new Error("Failed to read frame time.");if(u<=0)throw new Error("Failed to read frame time. Invalid value "+u);s.frameRate=1/u;for(let N=0;N<w;++N){const T=e.shift();if(!T)continue;const S=T.trim().split(/[\s]+/)||[];B(S,N,c,{i:0})}return s.root=c,P(s.root,null,s),s.skeleton.returnToRest(),s.skeleton}class d{constructor(t){this.name=g.name,this.extensions=g.extensions,this._loadingOptions={...d._DefaultLoadingOptions,...t??{}}}static get _DefaultLoadingOptions(){return{loopMode:h.ANIMATIONLOOPMODE_CYCLE}}createPlugin(t){return new d(t[g.name])}canDirectLoad(t){return this.isBvhHeader(t)}isBvhHeader(t){return t.split(`
`)[0]=="HIERARCHY"}isNotBvhHeader(t){return!this.isBvhHeader(t)}importMeshAsync(t,o,i){if(typeof i!="string")return Promise.reject("BVH loader expects string data.");if(this.isNotBvhHeader(i))return Promise.reject("BVH loader expects HIERARCHY header.");try{const e=A(i,o,null,this._loadingOptions);return Promise.resolve({meshes:[],particleSystems:[],skeletons:[e],animationGroups:[],transformNodes:[],geometries:[],lights:[],spriteManagers:[]})}catch(e){return Promise.reject(e)}}loadAsync(t,o){return typeof o!="string"?Promise.reject("BVH loader expects string data."):this.isNotBvhHeader(o)?Promise.reject("BVH loader expects HIERARCHY header."):this.importMeshAsync(null,t,o).then(()=>{})}loadAssetContainerAsync(t,o){if(typeof o!="string")return Promise.reject("BVH loader expects string data.");if(this.isNotBvhHeader(o))return Promise.reject("BVH loader expects HIERARCHY header.");const i=new D(t);try{const e=A(o,t,i,this._loadingOptions);return i.skeletons.push(e),Promise.resolve(i)}catch(e){return Promise.reject(e)}}}V(new d);export{d as BVHFileLoader};
