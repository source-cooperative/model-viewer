import{k as r,l as A,Q as F,m as b,h as g,u as L,r as w}from"./Mxg7T9gF.js";import{G as B,A as E}from"./3UQ8_E_Z.js";const c="EXT_mesh_gpu_instancing";class I{constructor(l){this.name=c,this._loader=l,this.enabled=this._loader.isExtensionUsed(c)}dispose(){this._loader=null}loadNodeAsync(l,o,T){return B.LoadExtensionAsync(l,o,this.name,async(h,m)=>{this._loader._disableInstancedMesh++;const d=this._loader.loadNodeAsync(`/nodes/${o.index}`,o,T);if(this._loader._disableInstancedMesh--,!o._primitiveBabylonMeshes)return await d;const u=new Array;let t=0;const i=a=>{if(m.attributes[a]==null){u.push(Promise.resolve(null));return}const s=E.Get(`${h}/attributes/${a}`,this._loader.gltf.accessors,m.attributes[a]);if(u.push(this._loader._loadFloatAccessorAsync(`/accessors/${s.bufferView}`,s)),t===0)t=s.count;else if(t!==s.count)throw new Error(`${h}/attributes: Instance buffer accessors do not have the same count.`)};return i("TRANSLATION"),i("ROTATION"),i("SCALE"),i("_COLOR_0"),await d.then(async a=>{const[s,_,y,n]=await Promise.all(u),p=new Float32Array(t*16);r.Vector3[0].copyFromFloats(0,0,0),r.Quaternion[0].copyFromFloats(0,0,0,1),r.Vector3[1].copyFromFloats(1,1,1);for(let e=0;e<t;++e)s&&A.FromArrayToRef(s,e*3,r.Vector3[0]),_&&F.FromArrayToRef(_,e*4,r.Quaternion[0]),y&&A.FromArrayToRef(y,e*3,r.Vector3[1]),b.ComposeToRef(r.Vector3[1],r.Quaternion[0],r.Vector3[0],r.Matrix[0]),r.Matrix[0].copyToArray(p,e*16);for(const e of o._primitiveBabylonMeshes)e.thinInstanceSetBuffer("matrix",p,16,!0),n&&(n.length===t*3?e.thinInstanceSetBuffer("color",n,3,!0):n.length===t*4?e.thinInstanceSetBuffer("color",n,4,!0):g.Warn("Unexpected size of _COLOR_0 attribute for mesh "+e.name));return a})})}}L(c);w(c,!0,f=>new I(f));export{I as EXT_mesh_gpu_instancing};
